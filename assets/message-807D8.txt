#ifdef GL_ES
precision highp float;
#endif

const float PI = 3.1415926535897932384626433832795;

varying vec2 surfacePosition;

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

const int max_iteration = 30;

float cabs (const vec2 c) { return dot(c,c); }

vec2 cconj(const vec2 c) { return vec2(c.x, -c.y); }


vec2 cmul(const vec2 c1, const vec2 c2)
{
    return vec2(
        c1.x * c2.x - c1.y * c2.y,
        c1.x * c2.y + c1.y * c2.x
    );
}

vec2 cdiv(const vec2 c1, const vec2 c2)
{
    return cmul(c1, cconj(c2)) / dot(c2, c2);
}


float saw (const float v)
{
    return sin(6.2*v) * 1.5 - 0.5;
    return abs(fract(v)-.5) * 2.5 - .5;
    return log(abs(1.-2.*fract(v+.5)) * 3.0);
}


vec3 Hue(float H)
{
    H *= 6.;
    return clamp(vec3(
        abs(H - 3.) - 1.,
        2. - abs(H - 2.),
        2. - abs(H - 4.)
    ), 0., 1.);
}

vec3 HSVtoRGB(float h, float s, float v)
{
    return ((Hue(h) - 1.) * s + 1.) * v;
}

float wave(float t) { return .5 - .5 * cos (t); }

vec2 one2 = vec2(1.,0.);

vec2 circle (float a) { return vec2 (cos(a), sin(a)); }

mat2 rotate(float a)
{
    return mat2(cos(a), -sin(a), sin(a), cos(a));
}

void main( void ) {
    float mytime = time + 1000.;
    
    vec2 c = vec2(.15-1.2*wave(mytime/7.2347890), -0.25-.5*wave(mytime/19.1345897));
    vec2 c2 = 3.25 * vec2(sin(mytime/18.175453), sin(mytime/16.2));
    
    float sinq = (2.*sin(mytime/255.4))+0.1;
    vec2 z = surfacePosition*sinq;
    vec2 z2 = surfacePosition * (1.5-sin(4.*sinq));
    
    float color = 0.;
    float colorb = 0.;
    float m = 0.;
    for (int i = 0; i < max_iteration; ++i)
    {
        m = cabs(z)*3.;
        
        vec2 zold = z;
        z = abs(cdiv(z, c*8. - c2*7.95)/m)*110.5 + c*1.;
        z2 = abs(cdiv(z2, c*3. - c2*2.1)/cabs(z2))*10.;
        color += exp(-cabs(z))*0.25;
        color += exp(-1./cabs(zold - z));
        colorb += exp(-2./cabs(z2))*0.25;
        colorb += exp(-cabs(zold - z2)*0.1)*0.53;
    }
    
    color /= float(max_iteration);

    gl_FragColor = vec4(HSVtoRGB(
        wave(color * (colorb) * sin(mytime/25.)),
        wave(color * 2.7891 + colorb),
        wave(color * 13.3234 + colorb *2.)
    ), 1.0);
    
}